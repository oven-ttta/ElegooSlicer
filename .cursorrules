# ElegooSlicer Project Development Rules

> Based on OrcaSlicer, developed by ELEGOO for FDM 3D printing

## Project Structure & Module Organization

ElegooSlicer's C++17 sources live in `src/`, split by feature modules and platform adapters:
- **Core slicing engine**: `src/libslic3r/`
- **GUI components**: `src/slic3r/GUI/`
- **Development utilities**: `src/dev-utils/`
- **User assets and presets**: `resources/` (icons, printer profiles, translations)
- **Translations**: `localization/`
- **Tests**: `tests/` (grouped by domain: `libslic3r/`, `sla_print/`, etc.)
- **Test fixtures**: `tests/data/`
- **CMake helpers**: `cmake/`
- **Documentation**: `doc/` and `SoftFever_doc/`
- **Automation scripts**: `scripts/` and `tools/`
- **Vendored dependencies**: `deps/` and `deps_src/` (treat as snapshots, do not modify without mirroring upstream)

## Build, Test, and Development Commands

**Out-of-source builds:**
```bash
# Configure and generate build files
cmake -S . -B build -DCMAKE_BUILD_TYPE=Release

# Compile the application (add --parallel to speed up)
cmake --build build --target ElegooSlicer --config Release

# Build and run tests
cmake --build build --target tests
ctest --test-dir build --output-on-failure
```

**Platform-specific helpers:**
- Linux: `build_linux.sh`
- macOS: `build_release_macos.sh` (use `-sx` flag for debugging build issues)
- Windows: `build_release_vs2022.bat`
- Docker: `scripts/DockerBuild.sh` (reproducible container builds)

## Testing Guidelines

- Unit tests use **Catch2** framework (`tests/catch2/`)
- Name test files after the component: e.g., `tests/libslic3r/TestPlanarHole.cpp`
- Tag long-running tests so `ctest -L fast` remains useful
- Use deterministic fixtures or sample G-code stored in `tests/data/`
- Document manual printer validation or regression checks in PR when automated coverage is insufficient

## Code Formatting

- **DO NOT use auto-formatting tools on existing code** - This project is based on OrcaSlicer branch, auto-formatting existing files will cause massive merge conflicts
- `.clang-format` exists in the project but **should NOT be applied to existing code**
- For **new files or new code blocks**, you may follow the formatting rules below, but do NOT reformat existing code
- When modifying existing files, **match the existing style** of that file to minimize diff

## Security & Configuration

- Follow `SECURITY.md` for vulnerability reporting
- Keep API tokens and printer credentials out of tracked configs
- Use `sandboxes/` for experimental settings
- When modifying third-party code in `deps_src/`, record upstream commit/release in PR description

## Language Requirements
- **All code comments MUST be written in English**
- **All git commit messages MUST be written in English**
- **All variable and function names MUST be in English**
- **File encoding MUST be UTF-8**
- Use clear, descriptive English that explains the "why" behind complex logic
- Keep comments concise and meaningful
- Absolutely NO Chinese characters in code, comments, or commit messages

## Important Guidelines for AI

### Code Modification Principles
1. **Do NOT automatically refactor existing code** - Due to historical reasons, much legacy code does not follow current naming conventions. Only modify code when explicitly requested by the user.

2. **Do NOT auto-format existing code** - This project is based on OrcaSlicer branch. Auto-formatting will cause massive merge conflicts with upstream. Match existing file style instead.

3. **Always read current file contents before making changes** - Do NOT rely solely on conversation context or memory. The user may have manually modified the code after previous AI changes. Always use the `read_file` tool to check the latest file state before editing.

4. **Respect manual user changes** - If the user has manually modified code between AI interactions, preserve those changes. Do not overwrite user modifications with previous AI suggestions from conversation history.

5. **Focus on requested changes only** - When asked to modify specific functionality, do not "improve" or "refactor" unrelated code, even if it doesn't follow current conventions.

6. **Ask before large refactoring** - If you notice code that could be improved but wasn't explicitly requested, mention it but do not change it without permission.

## Naming Conventions

### C++ (Backend)

**Files and Folders:**
- Project folders and image files: lowercase
- Code files: big camelCase (e.g., `BaseException.cpp`, `MainFrame.hpp`)
- File extensions: lowercase

**Classes, Structs, Enums:**
- Use big camelCase (first letter uppercase)
  - Example: `class ElegooClass`, `struct ElegooStruct`, `enum ElegooEnum`

**Macros:**
- Use all uppercase with underscores
  - Example: `#define ELEGOO_MACRO 0`

**Namespaces:**
- Use big camelCase (first letter uppercase)
  - Example: `namespace ElegooSpace {}`

**Variables:**
- **Local variables**: small camelCase (first letter lowercase)
  - Example: `int elegooVal{0};`
- **Global variables**: `g` prefix + big camelCase (first letter uppercase)
  - Example: `int gElegoo;` or `int gElegooVal;`
- **Static variables**: `s` prefix + big camelCase (first letter uppercase)
  - Example: `int sElegoo;` or `int sElegooVal;`
- **Member variables**: `m` prefix + big camelCase (first letter uppercase)
  - Example: `std::string mName;` or `std::string mUserName;`

**Functions:**
- **Regular functions**: small camelCase (first letter lowercase)
  - Example: `void elegooFunction(){}`
- **Slot functions**: `slot` prefix + big camelCase (first letter uppercase)
  - Example: `void slotElegoo(){}`
- **Signal functions**: `signal` prefix + big camelCase (first letter uppercase)
  - Example: `void signalElegoo(){}`
- **Lambda expressions**: small camelCase for lambda variables
  - Example: `auto processData = [](int x) { return x * 2; };`

### JavaScript (Frontend)
- **Variables**: small camelCase (first letter lowercase)
  - Example: `userInfo`, `loginStatus`, `avatarUrl`
- **Functions**: small camelCase (first letter lowercase)
  - Example: `onLogout()`, `ipcRequest()`, `checkLoginStatus()`
- **Classes**: big camelCase (first letter uppercase, same as C++)
  - Example: `NavigationController`, `UserManager`
- **Objects**: small camelCase (first letter lowercase)
  - Example: `userInfo`, `navigationData`

## Code Format and Style

### Basic Requirements (for new files only)
- **File encoding**: UTF-8 without BOM
- **Indentation**: 4 spaces (NO tabs)
- **Build system**: Use CMakeLists.txt for all builds

### Code Style Guidelines

**C++ Specific:**
- Follow existing codebase patterns in `src/libslic3r/` and `src/slic3r/`
- Use `#ifndef/#define` for header guards
- Prefer smart pointers (`std::unique_ptr`, `std::shared_ptr`) over raw pointers
- Use RAII patterns for resource management
- Keep functions focused and single-purpose

**JavaScript Specific:**
- Use ES6+ features (const/let, arrow functions, async/await)
- Prefer `const` over `let` when possible
- Use meaningful variable and function names
- Keep functions small and focused
- Use template literals for string concatenation

## Comment Standards

> **Note**: Keep inline comments concise. Use detailed Doxygen comments for public APIs and class interfaces.

### Header File Comments:
```cpp
// ------------------------------------------
// author: Your Name
// copyright: (c) 2024 ELEGOO
// description: This file contains the declaration of the class.
// ------------------------------------------

#ifndef CLASS_NAME_H
#define CLASS_NAME_H
```

### Class/Function/Variable Comments (Doxygen style):
```cpp
/**
 * @brief A class demonstrating usage.
 */
class ExampleClass 
{
public:
    /**
     * @brief Constructor for ExampleClass.
     * @param value An integer value to initialize the class.
     */
    ExampleClass(int value);

    /**
     * @brief Get the name value.
     * @return A reference to the name string.
     */
    const std::string& getName() const;

private:
    std::string mName;  //< Member variable storing the name
};
```

### Comment Types and Usage:
```cpp
// Inline comment - for quick explanations
int count = 0;  // Initialize counter

/* Block comment - for temporarily disabling code or multi-line notes
   Use sparingly, prefer multiple single-line comments
*/

/** 
 * Documentation comment - for public APIs, classes, and functions
 * Use Doxygen style with @brief, @param, @return
 */
```

## Parameter Passing Rules

1. **Add `const` for parameters that won't be modified**
   - Example: `void process(const std::string& data)`

2. **Use references to avoid copying**
   - Example: `void update(std::vector<int>& vec)` (not `void update(std::vector<int> vec)`)

3. **Prefer references over pointers when possible**
   - Example: `void set(const Config& config)` (not `void set(const Config* config)`)

4. **Consider move semantics for specific scenarios**
   - Example: `void transfer(std::vector<int>&& data)`

5. **Smart pointer passing**
   - Transfer ownership: `std::unique_ptr<T>` (by value or move)
   - Share ownership: `std::shared_ptr<T>` (by value or const reference)
   - Observe only: raw pointer `T*` or reference `T&`
   - Example: `void process(std::unique_ptr<Data> data)`, `void share(const std::shared_ptr<Data>& data)`

6. **Function parameters limit: max 4 parameters**
   - If more than 4, encapsulate into a struct

## Function Design Rules

> **Note**: These are guidelines, not absolute rules. Exceptions are allowed for valid reasons.

1. **Single Responsibility**: One function implements one feature only
2. **Function Length**: Recommended max 50 lines (guideline, not absolute)
3. **Nesting Depth**: Max 3 levels of nesting

## Pointer Safety

```cpp
// ✅ Always check pointers before use
if (ptr != nullptr) {
    ptr->doSomething();
}

// ✅ Use assertions for debug builds (note: assert is removed in release builds)
assert(ptr != nullptr && "Pointer should not be null");
if (ptr != nullptr) {
    ptr->doSomething();
}

// ✅ Set to nullptr after delete
delete ptr;
ptr = nullptr;
```

## Container Safety

```cpp
// ✅ Check size before accessing
std::vector<int> vec;
size_t index = 2;
if (index < vec.size()) {
    vec[index] = 0;
}

// ✅ If using signed index, check for negative values
int signedIndex = 2;
if (signedIndex >= 0 && static_cast<size_t>(signedIndex) < vec.size()) {
    vec[signedIndex] = 0;
}

// ✅ Check queue before popping
std::queue<int> queue;
if (!queue.empty()) {
    queue.pop();
}
```

## Variable Initialization

```cpp
// ✅ Always initialize variables
int elegooVal{0};
std::string name;  // Default constructor initializes to empty string
MyClass* ptr{nullptr};

// ❌ Never use uninitialized variables
int badVal;  // Dangerous!
```

## Header File Management

1. **Forward declarations**: Use forward declarations in headers when possible
   ```cpp
   // In .hpp file
   class OtherClass;  // Forward declaration
   
   // In .cpp file
   #include "OtherClass.hpp"  // Include only in implementation
   ```

2. **Include order**: Group headers logically
   ```cpp
   // C standard library
   #include <cstdio>
   #include <cstring>
   
   // C++ standard library
   #include <iostream>
   #include <vector>
   #include <string>
   #include <memory>
   
   // Third-party libraries
   #include <boost/filesystem.hpp>
   #include <wx/window.h>
   
   // Project headers
   #include "BaseException.h"
   #include "Utils.hpp"
   ```

## Class Design

1. **Member access order**: public → protected → private (no mixing)
   ```cpp
   class ElegooClass 
   {
   public:
       // Public members
   protected:
       // Protected members
   private:
       // Private members
   };
   ```

2. **Encapsulation**: Don't expose members directly; use getters/setters
   ```cpp
   class ElegooClass 
   {
   public:
       const std::string& getName() const { return mName; }
       void setName(const std::string& name) { mName = name; }
   private:
       std::string mName;
   };
   ```

3. **Deep copy**: Implement deep copy for classes with pointers/resources
4. **Move semantics**: Use move constructors for large objects to improve performance

## Code Maintenance

1. **Remove commented-out code** - delete obsolete code promptly
2. **Keep comments synchronized** - update comments when code changes
3. **Exception handling** - add try-catch where appropriate with logging
4. **Use namespaces** - wrap large feature modules in namespaces

## Code Quality

- **Extensibility**: Design for future extensions, avoid hardcoding
- **Unified styles**: Keep UI styles in a single file
- **String resources**: Use English strings; translate as needed

## Git Commit Message Standards

### Commit Message Format
```
<type>(<scope>): <subject>

<body>

<footer>
```

### Type (Required)
- **feat**: New feature
- **fix**: Bug fix
- **docs**: Documentation changes
- **style**: Code style changes (formatting, missing semicolons, etc)
- **refactor**: Code refactoring (neither fixes a bug nor adds a feature)
- **perf**: Performance improvements
- **test**: Adding or modifying tests
- **chore**: Changes to build process or auxiliary tools
- **revert**: Reverts a previous commit

### Scope (Optional)
Indicates which part of the codebase is affected:
- `gui`: GUI components
- `slicer`: Core slicing engine
- `network`: Network/cloud features
- `printer`: Printer management
- `config`: Configuration management
- `build`: Build system
- `deps`: Dependencies
- Or use specific module/class name (e.g., `BaseException`, `MainFrame`)

### Subject (Required)
- Use imperative mood: "add feature" not "added feature" or "adds feature"
- Start with lowercase
- No period at the end
- Maximum 50 characters
- Be specific and descriptive

### Body (Optional but Recommended)
- Explain WHAT and WHY, not HOW
- Wrap at 72 characters
- Separate from subject with a blank line
- Can include multiple paragraphs

### Footer (Optional)
- Reference issues: `Closes #123`, `Fixes #456`, `Relates to #789`
- Breaking changes: `BREAKING CHANGE: description`

### Examples:

**Good:**
```
feat(gui): add crash test menu for debugging

- Added simple crash test option in Help menu
- Helps verify crash reporting system works correctly
- Only visible in debug/development builds

Closes #234
```

```
fix(BaseException): fix crash issue in exception handling

Fixed crash that occurred when handling certain exceptions

1. Modified exception handling logic in BaseException.cpp
2. Added handling for special edge cases

Closes #123
```

```
refactor(network): simplify printer discovery logic

Removed redundant network checks and consolidated printer
status polling into a single method.
```

**Bad:**
```
fixed bug  // Too vague, no context
```

```
fixed stuff  // Too vague
```

```
update code  // Not descriptive enough
```

```
Added new feature.  // Wrong tense (should be "add")
```

### Commit Frequency
- Commit often, but keep commits atomic
- One logical change per commit
- Don't commit broken code
- Don't commit debugging code or commented-out code
- Don't commit unrelated changes together

### Git Workflow for Multi-Developer Teams

**When you have finished coding and ready to commit:**

```bash
# Step 1: Check current status
git status

# Step 2: Stage your changes
git add <modified-files>
# or: git add .  (add all changes)

# Step 3: Commit to LOCAL repository
git commit -m "type(scope): brief description"

# Step 4: Pull with rebase to maintain linear history (critical for multi-developer)
git pull --rebase origin <branch-name>

# Step 5a: If NO conflicts - directly push
git push origin <branch-name>

# Step 5b: If conflicts occur during rebase:
#   - Git will mark conflicted files
#   - Open and edit conflicted files (look for <<<<<<, ======, >>>>>> markers)
#   - Resolve conflicts manually
#   - Stage resolved files: git add <resolved-files>
#   - Continue rebase: git rebase --continue  (NOT git commit!)
#   - If more conflicts, repeat until done
#   - Then push: git push origin <branch-name>

# Step 5c: If you want to abort rebase and start over:
git rebase --abort
```

**Why use `--rebase` instead of regular pull?**
- Regular `git pull` creates merge commits → branching history
- `git pull --rebase` replays your commits on top of remote → **linear history**
- Linear history is cleaner and easier to understand

**Visualized:**
```
Without rebase (merge):     With rebase (linear):
A → B → C → merge           A → B → C → D
     ↘ D ↗                  (your commit moved on top)
```

**Common scenario:**
1. You start coding at 10:00 AM
2. You finish and commit at 11:00 AM (commit D)
3. Meanwhile, colleague pushed changes at 10:30 AM (commit C)
4. `git pull --rebase` will replay your commit D on top of C
5. Result: A → B → C → D (linear!)

### Before Committing
- [ ] Remove debugging code
- [ ] Remove commented-out code
- [ ] Test your changes
- [ ] Write meaningful commit message in English
- [ ] Keep code changes minimal (do NOT reformat existing code)

## Commit Content Rules

### What CAN be committed to repository:
- ✅ Source code files (.cpp, .hpp, .js, .html, .css)
- ✅ Build files (CMakeLists.txt, .bat, .sh)
- ✅ Resource files (images, translations, styles)
- ✅ Scripts and configuration files
- ✅ Third-party library headers
- ✅ Project documentation

### What CANNOT be committed:
- ❌ Build output/intermediate files (.obj, .o, .exe, .dll without source)
- ❌ Test images and temporary files
- ❌ IDE-specific files (except .cursorrules)
- ❌ Binary files without purpose
- ❌ Personal configuration files
- ❌ AI auto-generated documentation without explicit instruction (e.g., .md/.txt)

### Important Rules:
- **Configure .gitignore properly** - prevent accidental commits of build artifacts
- **Organize documentation** - put project docs in `doc/` folder
- **Update README** - document common issues and solutions

## File Organization
- C++ files: `src/libslic3r/`, `src/slic3r/GUI/`, `src/dev-utils/`
- JavaScript files: `resources/web/`
- Documentation: `doc/` folder
- Headers: Use `.hpp` extension for C++ headers
- Source: Use `.cpp` extension for C++ implementation
- All text files: **UTF-8 encoding**

## Prohibited Practices

### NEVER Do These:
1. **❌ Use Chinese in code, comments, or commit messages**
2. **❌ Commit broken/non-compiling code**
3. **❌ Commit directly to main/master branch**
4. **❌ Force push without team agreement**
5. **❌ Leave debugging code (console.log, printf, etc.)**
6. **❌ Leave commented-out code without explanation**
7. **❌ Use magic numbers (use named constants)**
8. **❌ Ignore compiler warnings**
9. **❌ Skip code review process**
10. **❌ Mix unrelated changes in one commit**
11. **❌ Let AI auto-generate or auto-commit documentation (.md/.txt) without explicit user request**
12. **❌ Automatically refactor legacy code to match new conventions without explicit request**
13. **❌ Overwrite user's manual changes with AI's previous suggestions from conversation history**
14. **❌ Make changes based solely on conversation context without reading current file contents**

## Code Review Checklist

### Before Submitting PR
- [ ] All comments are in English
- [ ] Naming conventions followed (with proper prefixes: g/s/m for global/static/member)
- [ ] Code follows existing patterns
- [ ] Commit messages are in English and descriptive
- [ ] No Chinese characters anywhere in code
- [ ] No debugging/test code left in
- [ ] No commented-out code (remove or explain why it's there)
- [ ] Code is properly formatted
- [ ] No compiler warnings
- [ ] All tests pass
- [ ] Documentation updated if needed

### Code Quality Standards
- [ ] Functions are focused and single-purpose
- [ ] No magic numbers (use constants)
- [ ] Error handling is appropriate
- [ ] Resource cleanup is proper (RAII in C++)
- [ ] No memory leaks
- [ ] Thread-safety considered for concurrent code
- [ ] Performance impact considered for critical paths

### Security Considerations
- [ ] Input validation implemented
- [ ] No hardcoded credentials
- [ ] Sensitive data properly handled
- [ ] SQL injection prevention (if applicable)
- [ ] Cross-site scripting prevention (if applicable)

## Examples

### Good C++ Code:
```cpp
/**
 * @brief Example class with proper encapsulation
 */
class UserConfig 
{
public:
    const std::string& getName() const { return mName; }
    void setName(const std::string& name) { mName = name; }
    
private:
    std::string mName;     //< User name
    int mUserId{0};        //< User ID (initialized)
};

/**
 * @brief Process user data with proper parameter passing
 */
void processUserData(const std::string& username, int userId)
{
    // Validate input
    if (username.empty())
    {
        return;
    }
    
    // Process data...
}
```

### Good JavaScript Code:
```javascript
// Handle user logout action
async onLogout() {
    console.log('Logout clicked');
    try {
        await this.ipcRequest('logout', {});
        // Reset user info after successful logout
        this.userInfo.loginStatus = 0;
        this.userInfo.nickname = '';
    } catch (error) {
        console.error('Logout failed:', error);
    }
}
```

### Good Commit Message:
```
fix(BaseException): fix crash issue in serialization

Fixed crash that occurred when serializing certain objects

1. Modified serialization logic in BaseException.cpp
2. Added handling for special edge cases

Closes #123
```

---

## Quick Reference Card

### Naming
- C++ variables/functions: small camelCase (first letter lowercase)
- C++ classes/structs/enums: big camelCase (first letter uppercase)
- C++ member variables: `m` + big camelCase (e.g., `mUserName`)
- C++ global variables: `g` + big camelCase (e.g., `gElegooVal`)
- C++ static variables: `s` + big camelCase (e.g., `sElegooVal`)
- C++ macros: all uppercase with underscores (e.g., `ELEGOO_MACRO`)
- JS variables/functions: small camelCase (first letter lowercase)

### Git Commits
- Format: `<type>(<scope>): <subject>`
- Types: feat, fix, docs, style, refactor, perf, test, chore
- Subject: lowercase, imperative, < 50 chars
- Language: **English ONLY**

### Comments
- Language: **English ONLY**
- Explain WHY, not WHAT
- Keep concise and meaningful

---

**Remember**: 
- ✅ Consistency is key
- ✅ Always use English
- ✅ Code quality over speed
- ✅ Review your own code before submitting
- ✅ Test your changes thoroughly
- ✅ Always read current file contents before editing
- ✅ Respect user's manual changes
- ✅ Only modify what was explicitly requested
